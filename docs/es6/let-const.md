# let和const命令

## 2.1 let命令

### 2.1.1 基本用法

ES5新增了let命令，用于声明变量。其用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。
``` js
{
    let a = 10;
    var b = 1
}
a // ReferenceError: a is not defined
b // 1
```
上面的代码块在代码块中分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在其所在的代码块内有效。

for循环的计数器就很适合适用let命令。
```js
for (let i = 0; i < 10; i++) {
    // ...
} 

console.log(i);
// ReferenceError: i is not defined
```
以上代码中的计数器i只在for循环体内有效，在循环体外引用就会报错。

下面的代码如果使用var，最后将输出10。
```js
var a = [];
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    };
}
a[6](); // 10
```
上面的代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生变化，而循环内，被赋给数组a的函数内部的console.log(i)中的i指向全局的i。也就是说，所有数组中的i指向的都是同一个i，导致运行时输出的是最后一轮的i值，也就是10。

如果适用let，声明的变量仅在块级作用域内有效，最后将输出6。
```js
var a = [];
for (let i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i);
    };
}
a[6](); // 6
```
上面代码块中，变量i是let声明的，当前的i只在本轮循环有效。所以每一次循环的i其实都是一个新的变量，于是最后输出的是6。大家可能会问，如果每一次循环的变量i都是重新声明的，那它怎么知道上一轮循环的值从而计算出本轮循环的值呢？这是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮循环的变量i时，就在上一轮循环的基础上进行计算。

另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
```js
for (let i = 0; i < 3; i++) {
    let i = 'abc';
    console.log(i);
}
// abc
// abc
// abc
```
正确运行以上代码将输出3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，而是有各自单独的作用域。
